// The MiMCSponge contract is not written in Solidity. Instead, its bytecode is
// generated by circomlib/src/mimcsponge_gencontract.js.
//
// Most (if not all) Solidity tooling frameworks, like Etherlime or Truffle,
// do not integrate the solc binary and therefore take ages to compile
// contracts.
//
// This script does the following:
//
// 1. Build the MiMC contract bytecode and deploy it to the Ethereum node
//    specified by --rpcUrl.
// 2. Copy Solidity files from the semaphore submodule to sol/semaphore
// 2. Compile the Solidity files specified by --input using the solc binary
//    specified by --solc. All output files will be in the directory specified
//    by --out.
// 3. Link the MiMC contract address to hardcoded contract(s) (just
//    MerkleTreeLib for now)
// 4. Deploy the rest of the contracts


// import { config } from 'su-config'
import { ArgumentParser } from 'argparse'
import * as shell from 'shelljs'
import * as path from 'path'
import * as fs from 'fs'
import * as ethers from 'ethers'
import * as ls from 'local-storage'

const mimcGenContract = require('circomlib/src/mimcsponge_gencontract.js')
const MIMC_SEED = 'mimcsponge'

const buildMimcBytecode = () => {
    return mimcGenContract.createCode(MIMC_SEED, 220)
}

const execute = (cmd) => {
    const result = shell.exec(cmd, { silent: false })
    if (result.code !== 0) {
        throw 'Error executing ' + cmd
    }

    return result
}

const readFile = (abiDir, filename) => {
    return fs.readFileSync(path.join(abiDir, filename)).toString()
}

const compileAbis = async (
    abiDir,
    solDir,
    solcBinaryPath = 'solc',
) => {
    shell.mkdir('-p', abiDir)
    const solcCmd = `${solcBinaryPath} -o ${abiDir} ${solDir}/*.sol --overwrite --abi`
    const result = execute(solcCmd)

    shell.rm('-rf', '../frontend/src/abi/')

    // Copy ABIs to the frontend and backend modules
    shell.mkdir('-p', '../frontend/src/abi/')

    shell.ls(path.join(abiDir, '*.abi')).forEach((file) => {
        const baseName = path.basename(file)
        shell.cp('-R', file, `../frontend/src/abi/${baseName}.json`)
    })
}

const compileAndDeploy = async (
    abiDir,
    solDir,
    solcBinaryPath = 'solc',
    rpcUrl = 'http://localhost:8545',
) => {

    const readAbiAndBin = (name) => {
        const abi = readFile(abiDir, name + '.abi')
        const bin = readFile(abiDir, name + '.bin')
        return { abi, bin }
    }

    // copy Semaphore files
    const semaphorePathPrefix = './sol/'

    // const semaphoreSolFiles = ['Semaphore.sol', 'IncrementalMerkleTree.sol', 'Ownable.sol', 'SnarkConstants.sol', 'MiMC.sol']
    // for (let file of semaphoreSolFiles) {
    //     shell.cp('-f', path.join(semaphorePathPrefix, file), solDir)
    // }

    // shell.cp('-f', path.join(semaphorePathPrefix, '.sol/verifier.sol'), solDir)

    // Build MiMC bytecode
    const mimcBin = buildMimcBytecode()

    // compile contracts
    shell.rm('-rf', abiDir)

    shell.mkdir('-p', abiDir)
    const solcCmd = `${solcBinaryPath} -o ${abiDir} ${solDir}/*.sol --overwrite --optimize --abi --bin`
    const result = execute(solcCmd)

    // create provider and wallet
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl)
    const deployKey = "0x65a694ae485808ee346228f59a1eb9dd2b6d1b1f4b0212007469b7452118d9ba"
    const wallet = new ethers.Wallet(deployKey, provider)

    // deploy MiMC
   try{ const mimcAbi = mimcGenContract.abi
    const mimcContractFactory = new ethers.ContractFactory(mimcAbi, mimcBin, wallet)

    const mimcContract = await mimcContractFactory.deploy(
        {gasPrice: ethers.utils.parseUnits('10', 'gwei')}
    )
    await mimcContract.deployed()
    console.log('MiMC deployed at', mimcContract.address)

     // link contracts to MiMC
     const filesToLink = ['MiMC.sol']
     for (let fileToLink of filesToLink) {
         const filePath = path.join(solDir, fileToLink)
         const linkCmd = `${solcCmd} --libraries ${filePath}:MiMC:${mimcContract.address}`
         execute(linkCmd)
     }
    // deploy Semaphore
    const semaphoreAB = readAbiAndBin('Semaphore')
    const semaphoreContractFactory = new ethers.ContractFactory(semaphoreAB.abi, semaphoreAB.bin, wallet)
    const semaphoreContract = await semaphoreContractFactory.deploy(
        20,
        0,
        { gasPrice: ethers.utils.parseUnits('10', 'gwei'), gasLimit: 8800000 },
    )
    await semaphoreContract.deployed()

    console.log('Deployed Semaphore at', semaphoreContract.address)


    // deploy SemaphoreClient
    const scAB = readAbiAndBin('Client')
    const scContractFactory = new ethers.ContractFactory(scAB.abi, scAB.bin, wallet)
    const scContract = await scContractFactory.deploy(
        semaphoreContract.address,
        {gasPrice: ethers.utils.parseUnits('10', 'gwei')},
    )
    await scContract.deployed()
    console.log('Deployed Client Contract at', scContract.address)
    shell.rm('-rf', '../frontend/src/addr/')

    shell.mkdir('-p', '../frontend/src/addr/')
    execute('touch ../frontend/src/addr/addr.json');    

    shell.env.semAddr = String(semaphoreContract.address);
    shell.env.scAddr = String(scContract.address);
    shell.env.json = execute(`jo -p -- -s semAddr=$semAddr -s scAddr=$scAddr`)
    execute(`echo $json >> ../frontend/src/addr/addr.json`)


    // set the owner of the Semaphore contract to the SemaphoreClient contract address
    const tx = await semaphoreContract.transferOwnership(scContract.address)
    await tx.wait()
    console.log('Transferred ownership of the Semaphore contract')

    return {
            MiMC: mimcContract,
            Semaphore: semaphoreContract,
            Client: scContract,
        }
}catch(e) {
    console.log(e)
}
   

    

    
	
		
	
}


if (require.main === module) {
    const parser = new ArgumentParser({
        description: 'Build and deploy contracts'
    })

    parser.addArgument(
        ['-s', '--solc'],
        {
            help: 'The path to the solc binary',
            required: false,
        }
    )

    parser.addArgument(
        ['-r', '--rpcUrl'],
        {
            help: 'The JSON-RPC URL of the Ethereum node',
            required: false,
        }
    )

    parser.addArgument(
        ['-o', '--out'],
        {
            help: 'The output directory for compiled files',
            required: true,
        }
    )

    parser.addArgument(
        ['-i', '--input'],
        {
            help: 'The input directory with .sol files',
            required: true,
        }
    )

    parser.addArgument(
        ['-k', '--privKey'],
        {
            help: 'The private key to use to deploy the contracts',
            required: false,
        }
    )

    parser.addArgument(
        ['-a', '--abi-only'],
        {
            help: 'Only generate ABI files',
            action: 'storeTrue',
        }
    )

    // parse command-line options
    const args = parser.parseArgs()

    const abiDir = path.resolve(args.out)
    const solDir = path.resolve(args.input)
    const solcBinaryPath = args.solc ? args.solc : 'solc'

    if (args.abi_only) {
        compileAbis(abiDir, solDir)
    } else {
        const rpcUrl = args.rpcUrl ? args.rpcUrl : "http://localhost:8545"

        compileAndDeploy(abiDir, solDir, solcBinaryPath, rpcUrl)
        compileAbis(abiDir, solDir)
    }
}

export {
    compileAndDeploy,
}
