{"id":"node_modules/semaphore-merkle-tree/build/merkletree.js","dependencies":[{"name":"/Users/riyasingh/myapps/semaphore-mini/packages/newfrontend/node_modules/semaphore-merkle-tree/build/merkletree.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/riyasingh/myapps/semaphore-mini/packages/newfrontend/node_modules/semaphore-merkle-tree/ts/merkletree.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/riyasingh/myapps/semaphore-mini/packages/newfrontend/package.json","includedInParent":true,"mtime":1615340050722},{"name":"/Users/riyasingh/myapps/semaphore-mini/packages/newfrontend/.babelrc","includedInParent":true,"mtime":1615332365597},{"name":"/Users/riyasingh/myapps/semaphore-mini/packages/newfrontend/node_modules/semaphore-merkle-tree/package.json","includedInParent":true,"mtime":1615335221010},{"name":"await-lock","loc":{"line":39,"column":24},"parent":"/Users/riyasingh/myapps/semaphore-mini/packages/newfrontend/node_modules/semaphore-merkle-tree/build/merkletree.js","resolved":"/Users/riyasingh/myapps/semaphore-mini/packages/newfrontend/node_modules/await-lock/build/AwaitLock.js"}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nexports.__esModule = true;\nvar AwaitLock = require('await-lock');\nvar MerkleTree = /** @class */ (function () {\n    function MerkleTree(prefix, storage, hasher, n_levels, zero_value) {\n        this.prefix = prefix;\n        this.storage = storage;\n        this.hasher = hasher;\n        this.n_levels = n_levels;\n        this.zero_values = [];\n        var current_zero_value = zero_value;\n        this.zero_values.push(current_zero_value);\n        for (var i = 0; i < n_levels; i++) {\n            current_zero_value = this.hasher.hash(i, current_zero_value, current_zero_value);\n            this.zero_values.push(current_zero_value.toString());\n        }\n        this.lock = new AwaitLock();\n    }\n    MerkleTree.index_to_key = function (prefix, level, index) {\n        var key = prefix + \"_tree_\" + level + \"_\" + index;\n        return key;\n    };\n    MerkleTree.element_to_key = function (prefix, element) {\n        var key = prefix + \"_element_\" + element;\n        return key;\n    };\n    MerkleTree.update_log_to_key = function (prefix) {\n        return prefix + \"_update_log_index\";\n    };\n    MerkleTree.update_log_element_to_key = function (prefix, update_log_index) {\n        return prefix + \"_update_log_element_\" + update_log_index;\n    };\n    MerkleTree.prototype.update_log = function (index, old_element, new_element, update_log_index, should_put_element_update) {\n        return __awaiter(this, void 0, void 0, function () {\n            var ops, update_log_key, update_log_element_key;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ops = [];\n                        update_log_key = MerkleTree.update_log_to_key(this.prefix);\n                        ops.push({\n                            type: 'put',\n                            key: update_log_key,\n                            value: update_log_index.toString()\n                        });\n                        if (should_put_element_update) {\n                            update_log_element_key = MerkleTree.update_log_element_to_key(this.prefix, update_log_index);\n                            ops.push({\n                                type: 'put',\n                                key: update_log_element_key,\n                                value: JSON.stringify({\n                                    index: index,\n                                    old_element: old_element,\n                                    new_element: new_element\n                                })\n                            });\n                        }\n                        return [4 /*yield*/, this.storage.put_batch(ops)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    MerkleTree.prototype.root = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var root;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.storage.get_or_element(MerkleTree.index_to_key(this.prefix, this.n_levels, 0), this.zero_values[this.n_levels])];\n                    case 1:\n                        root = _a.sent();\n                        return [2 /*return*/, root];\n                }\n            });\n        });\n    };\n    MerkleTree.prototype.element_index = function (element) {\n        return __awaiter(this, void 0, void 0, function () {\n            var element_key, index;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        element_key = MerkleTree.element_to_key(this.prefix, element);\n                        return [4 /*yield*/, this.storage.get_or_element(element_key, -1)];\n                    case 1:\n                        index = _a.sent();\n                        return [2 /*return*/, parseInt(index)];\n                }\n            });\n        });\n    };\n    MerkleTree.prototype.path = function (index) {\n        return __awaiter(this, void 0, void 0, function () {\n            var PathTraverser, traverser, root, element;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        PathTraverser = /** @class */ (function () {\n                            function PathTraverser(prefix, storage, zero_values) {\n                                this.prefix = prefix;\n                                this.storage = storage;\n                                this.zero_values = zero_values;\n                                this.path_elements = [];\n                                this.path_index = [];\n                            }\n                            PathTraverser.prototype.handle_index = function (level, element_index, sibling_index) {\n                                return __awaiter(this, void 0, void 0, function () {\n                                    var sibling;\n                                    return __generator(this, function (_a) {\n                                        switch (_a.label) {\n                                            case 0: return [4 /*yield*/, this.storage.get_or_element(MerkleTree.index_to_key(this.prefix, level, sibling_index), this.zero_values[level])];\n                                            case 1:\n                                                sibling = _a.sent();\n                                                this.path_elements.push(sibling);\n                                                this.path_index.push(element_index % 2);\n                                                return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            };\n                            return PathTraverser;\n                        }());\n                        traverser = new PathTraverser(this.prefix, this.storage, this.zero_values);\n                        return [4 /*yield*/, this.storage.get_or_element(MerkleTree.index_to_key(this.prefix, this.n_levels, 0), this.zero_values[this.n_levels])];\n                    case 1:\n                        root = _a.sent();\n                        return [4 /*yield*/, this.storage.get_or_element(MerkleTree.index_to_key(this.prefix, 0, index), this.zero_values[0])];\n                    case 2:\n                        element = _a.sent();\n                        return [4 /*yield*/, this.traverse(index, traverser)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, {\n                                root: root,\n                                path_elements: traverser.path_elements,\n                                path_index: traverser.path_index,\n                                element: element\n                            }];\n                }\n            });\n        });\n    };\n    MerkleTree.prototype.update = function (index, leaf, update_log_index, lock_already_acquired) {\n        return __awaiter(this, void 0, void 0, function () {\n            var element, UpdateTraverser, traverser, update_log_key, update_log_index_from_db, root;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        element = leaf.toString();\n                        if (!!lock_already_acquired) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.lock.acquireAsync()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, , 12, 13]);\n                        UpdateTraverser = /** @class */ (function () {\n                            function UpdateTraverser(prefix, storage, hasher, element, zero_values) {\n                                this.prefix = prefix;\n                                this.current_element = element;\n                                this.zero_values = zero_values;\n                                this.storage = storage;\n                                this.hasher = hasher;\n                                this.key_values_to_put = [];\n                            }\n                            UpdateTraverser.prototype.handle_index = function (level, element_index, sibling_index) {\n                                return __awaiter(this, void 0, void 0, function () {\n                                    var _a, sibling, left, right;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                if (!(level == 0)) return [3 /*break*/, 2];\n                                                _a = this;\n                                                return [4 /*yield*/, this.storage.get_or_element(MerkleTree.index_to_key(this.prefix, level, element_index), this.zero_values[level])];\n                                            case 1:\n                                                _a.original_element = _b.sent();\n                                                this.key_values_to_put.push({\n                                                    key: MerkleTree.element_to_key(this.prefix, element),\n                                                    value: index.toString()\n                                                });\n                                                _b.label = 2;\n                                            case 2: return [4 /*yield*/, this.storage.get_or_element(MerkleTree.index_to_key(this.prefix, level, sibling_index), this.zero_values[level])];\n                                            case 3:\n                                                sibling = _b.sent();\n                                                if (element_index % 2 == 0) {\n                                                    left = this.current_element;\n                                                    right = sibling;\n                                                }\n                                                else {\n                                                    left = sibling;\n                                                    right = this.current_element;\n                                                }\n                                                this.key_values_to_put.push({\n                                                    key: MerkleTree.index_to_key(this.prefix, level, element_index),\n                                                    value: this.current_element\n                                                });\n                                                //console.log(`left: ${left}, right: ${right}`);\n                                                this.current_element = this.hasher.hash(level, left, right);\n                                                return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            };\n                            return UpdateTraverser;\n                        }());\n                        traverser = new UpdateTraverser(this.prefix, this.storage, this.hasher, element, this.zero_values);\n                        return [4 /*yield*/, this.traverse(index, traverser)];\n                    case 3:\n                        _a.sent();\n                        //console.log(`traverser.current_element: ${traverser.current_element}`);\n                        traverser.key_values_to_put.push({\n                            key: MerkleTree.index_to_key(this.prefix, this.n_levels, 0),\n                            value: traverser.current_element\n                        });\n                        if (!(update_log_index == undefined)) return [3 /*break*/, 6];\n                        update_log_key = MerkleTree.update_log_to_key(this.prefix);\n                        return [4 /*yield*/, this.storage.get_or_element(update_log_key, -1)];\n                    case 4:\n                        update_log_index_from_db = _a.sent();\n                        update_log_index = parseInt(update_log_index_from_db) + 1;\n                        return [4 /*yield*/, this.update_log(index, traverser.original_element, element, update_log_index, true)];\n                    case 5:\n                        _a.sent();\n                        return [3 /*break*/, 8];\n                    case 6: return [4 /*yield*/, this.update_log(index, traverser.original_element, element, update_log_index, false)];\n                    case 7:\n                        _a.sent();\n                        _a.label = 8;\n                    case 8: return [4 /*yield*/, this.storage.del(MerkleTree.element_to_key(this.prefix, traverser.original_element))];\n                    case 9:\n                        _a.sent();\n                        //traverser.key_values_to_put.forEach((e) => console.log(`key_values: ${JSON.stringify(e)}`));\n                        return [4 /*yield*/, this.storage.put_batch(traverser.key_values_to_put)];\n                    case 10:\n                        //traverser.key_values_to_put.forEach((e) => console.log(`key_values: ${JSON.stringify(e)}`));\n                        _a.sent();\n                        return [4 /*yield*/, this.root()];\n                    case 11:\n                        root = _a.sent();\n                        return [3 /*break*/, 13];\n                    case 12:\n                        if (!lock_already_acquired) {\n                            this.lock.release();\n                        }\n                        return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    MerkleTree.prototype.traverse = function (index, handler) {\n        return __awaiter(this, void 0, void 0, function () {\n            var current_index, i, sibling_index;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        current_index = index;\n                        i = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i < this.n_levels)) return [3 /*break*/, 4];\n                        sibling_index = current_index;\n                        if (current_index % 2 == 0) {\n                            sibling_index += 1;\n                        }\n                        else {\n                            sibling_index -= 1;\n                        }\n                        return [4 /*yield*/, handler.handle_index(i, current_index, sibling_index)];\n                    case 2:\n                        _a.sent();\n                        current_index = Math.floor(current_index / 2);\n                        _a.label = 3;\n                    case 3:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    MerkleTree.prototype.rollback = function (updates) {\n        return __awaiter(this, void 0, void 0, function () {\n            var update_log_key, update_log_index, i, update_log_element_key, update_element_log, _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.lock.acquireAsync()];\n                    case 1:\n                        _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        _c.trys.push([2, , 9, 10]);\n                        update_log_key = MerkleTree.update_log_to_key(this.prefix);\n                        return [4 /*yield*/, this.storage.get(update_log_key)];\n                    case 3:\n                        update_log_index = _c.sent();\n                        i = 0;\n                        _c.label = 4;\n                    case 4:\n                        if (!(i < updates)) return [3 /*break*/, 8];\n                        update_log_element_key = MerkleTree.update_log_element_to_key(this.prefix, update_log_index - i);\n                        _b = (_a = JSON).parse;\n                        return [4 /*yield*/, this.storage.get(update_log_element_key)];\n                    case 5:\n                        update_element_log = _b.apply(_a, [_c.sent()]);\n                        return [4 /*yield*/, this.update(update_element_log.index, update_element_log.old_element, update_log_index - i - 1, true)];\n                    case 6:\n                        _c.sent();\n                        _c.label = 7;\n                    case 7:\n                        i++;\n                        return [3 /*break*/, 4];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        this.lock.release();\n                        return [7 /*endfinally*/];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    MerkleTree.prototype.rollback_to_root = function (root) {\n        return __awaiter(this, void 0, void 0, function () {\n            var update_log_key, update_log_index, update_log_element_key, update_element_log, _a, _b, current_root;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.lock.acquireAsync()];\n                    case 1:\n                        _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        _c.trys.push([2, , 10, 11]);\n                        update_log_key = MerkleTree.update_log_to_key(this.prefix);\n                        return [4 /*yield*/, this.storage.get(update_log_key)];\n                    case 3:\n                        update_log_index = _c.sent();\n                        _c.label = 4;\n                    case 4:\n                        if (!(update_log_index >= 0)) return [3 /*break*/, 8];\n                        update_log_element_key = MerkleTree.update_log_element_to_key(this.prefix, update_log_index);\n                        _b = (_a = JSON).parse;\n                        return [4 /*yield*/, this.storage.get(update_log_element_key)];\n                    case 5:\n                        update_element_log = _b.apply(_a, [_c.sent()]);\n                        return [4 /*yield*/, this.update(update_element_log.index, update_element_log.old_element, update_log_index, true)];\n                    case 6:\n                        _c.sent();\n                        return [4 /*yield*/, this.root()];\n                    case 7:\n                        current_root = _c.sent();\n                        if (current_root == root) {\n                            return [3 /*break*/, 8];\n                        }\n                        update_log_index -= 1;\n                        return [3 /*break*/, 4];\n                    case 8: return [4 /*yield*/, this.root()];\n                    case 9:\n                        if ((_c.sent()) != root) {\n                            throw new Error(\"could not rollback to root \" + root);\n                        }\n                        return [3 /*break*/, 11];\n                    case 10:\n                        this.lock.release();\n                        return [7 /*endfinally*/];\n                    case 11: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return MerkleTree;\n}());\nexports[\"default\"] = MerkleTree;\n"},"sourceMaps":{"js":{"version":3,"file":"merkletree.js","sourceRoot":"","sources":["../ts/merkletree.ts"],"names":[],"mappings":"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","sourcesContent":["import { IStorage } from './storage'\nimport { IHasher } from './hashers'\n\nconst AwaitLock = require('await-lock')\n\nexport default class MerkleTree {\n    public prefix: string\n    public storage: IStorage\n    public hasher: IHasher\n    public n_levels: number\n    public zero_values: any[]\n    public lock: any\n\n    constructor(prefix, storage, hasher, n_levels, zero_value) {\n        this.prefix = prefix;\n        this.storage = storage;\n        this.hasher = hasher;\n        this.n_levels = n_levels;\n        this.zero_values = [];\n\n        let current_zero_value = zero_value;\n        this.zero_values.push(current_zero_value);\n        for (let i = 0; i < n_levels; i++) {\n            current_zero_value = this.hasher.hash(i, current_zero_value, current_zero_value);\n            this.zero_values.push(\n                current_zero_value.toString(),\n            );\n        }\n        this.lock = new AwaitLock();\n    }\n\n    static index_to_key(prefix, level, index) {\n        const key = `${prefix}_tree_${level}_${index}`;\n        return key;\n    }\n\n    static element_to_key(prefix, element) {\n        const key = `${prefix}_element_${element}`;\n        return key;\n    }\n\n    static update_log_to_key(prefix) {\n        return `${prefix}_update_log_index`;\n    }\n\n    static update_log_element_to_key(prefix, update_log_index) {\n        return `${prefix}_update_log_element_${update_log_index}`;\n    }\n\n    async update_log(index, old_element, new_element, update_log_index, should_put_element_update) {\n        let ops: any[] = []\n\n        const update_log_key = MerkleTree.update_log_to_key(this.prefix);\n        ops.push({\n            type: 'put',\n            key: update_log_key,\n            value: update_log_index.toString(),\n        });\n\n        if (should_put_element_update) {\n            const update_log_element_key = MerkleTree.update_log_element_to_key(this.prefix, update_log_index);\n            ops.push({\n                type: 'put',\n                key: update_log_element_key,\n                value: JSON.stringify({\n                    index,\n                    old_element,\n                    new_element,\n                })\n            });\n        }\n        await this.storage.put_batch(ops);\n    }\n\n    async root() {\n        let root = await this.storage.get_or_element(\n            MerkleTree.index_to_key(this.prefix, this.n_levels, 0),\n            this.zero_values[this.n_levels],\n        );\n\n        return root;\n    }\n\n    async element_index(element) {\n        const element_key = MerkleTree.element_to_key(this.prefix, element);\n        const index = await this.storage.get_or_element(element_key, -1);\n        return parseInt(index);\n    }\n\n    async path(index) {\n        class PathTraverser {\n            public prefix: string\n            public storage: IStorage\n            public zero_values: any[]\n            public path_elements: string[]\n            public path_index: number[]\n            constructor(prefix, storage, zero_values) {\n                this.prefix = prefix;\n                this.storage = storage;\n                this.zero_values = zero_values;\n                this.path_elements = [];\n                this.path_index = [];\n            }\n\n            async handle_index(level, element_index, sibling_index) {\n                const sibling = await this.storage.get_or_element(\n                    MerkleTree.index_to_key(this.prefix, level, sibling_index),\n                    this.zero_values[level],\n                );\n                this.path_elements.push(sibling);\n                this.path_index.push(element_index % 2);\n            }\n        }\n        let traverser = new PathTraverser(this.prefix, this.storage, this.zero_values);\n        const root = await this.storage.get_or_element(\n            MerkleTree.index_to_key(this.prefix, this.n_levels, 0),\n            this.zero_values[this.n_levels],\n        );\n\n        const element = await this.storage.get_or_element(\n            MerkleTree.index_to_key(this.prefix, 0, index),\n            this.zero_values[0],\n        );\n\n        await this.traverse(index, traverser);\n        return {\n            root,\n            path_elements: traverser.path_elements,\n            path_index: traverser.path_index,\n            element\n        };\n    }\n\n    async update(index, leaf, update_log_index?: number, lock_already_acquired?: boolean) {\n        const element = leaf.toString()\n        if (!lock_already_acquired) {\n            await this.lock.acquireAsync();\n        }\n        try {\n            //console.log(`updating ${index}, ${element}`);\n            class UpdateTraverser {\n                public prefix: string\n                public storage: IStorage\n                public zero_values: any[]\n                public current_element: any\n                public original_element: any\n                public hasher: IHasher\n                public key_values_to_put: any[]\n\n                constructor(prefix, storage, hasher, element, zero_values) {\n                    this.prefix = prefix;\n                    this.current_element = element;\n                    this.zero_values = zero_values;\n                    this.storage = storage;\n                    this.hasher = hasher;\n                    this.key_values_to_put = [];\n                }\n\n                async handle_index(level, element_index, sibling_index) {\n                    if (level == 0) {\n                        this.original_element = await this.storage.get_or_element(\n                            MerkleTree.index_to_key(this.prefix, level, element_index),\n                            this.zero_values[level],\n                        );\n                        this.key_values_to_put.push({\n                            key: MerkleTree.element_to_key(this.prefix, element),\n                            value: index.toString(),\n                        });\n\n                    }\n                    const sibling = await this.storage.get_or_element(\n                        MerkleTree.index_to_key(this.prefix, level, sibling_index),\n                        this.zero_values[level],\n                    );\n                    let left, right;\n                    if (element_index % 2 == 0) {\n                        left = this.current_element;\n                        right = sibling;\n                    } else {\n                        left = sibling;\n                        right = this.current_element;\n                    }\n\n                    this.key_values_to_put.push({\n                        key: MerkleTree.index_to_key(this.prefix, level, element_index),\n                        value: this.current_element,\n                    });\n                    //console.log(`left: ${left}, right: ${right}`);\n                    this.current_element = this.hasher.hash(level, left, right);\n                    //console.log(`current_element: ${this.current_element}`);\n                }\n            }\n            let traverser = new UpdateTraverser(\n                this.prefix,\n                this.storage,\n                this.hasher,\n                element,\n                this.zero_values\n            );\n\n            await this.traverse(index, traverser);\n            //console.log(`traverser.current_element: ${traverser.current_element}`);\n            traverser.key_values_to_put.push({\n                key: MerkleTree.index_to_key(this.prefix, this.n_levels, 0),\n                value: traverser.current_element,\n            });\n\n            if (update_log_index == undefined) {\n                const update_log_key = MerkleTree.update_log_to_key(this.prefix);\n                let update_log_index_from_db = await this.storage.get_or_element(update_log_key, -1);\n                update_log_index = parseInt(update_log_index_from_db) + 1;\n                await this.update_log(index, traverser.original_element, element, update_log_index, true);\n            } else {\n                await this.update_log(index, traverser.original_element, element, update_log_index, false);\n            }\n\n            await this.storage.del(MerkleTree.element_to_key(this.prefix, traverser.original_element));\n            //traverser.key_values_to_put.forEach((e) => console.log(`key_values: ${JSON.stringify(e)}`));\n            await this.storage.put_batch(traverser.key_values_to_put);\n\n            const root = await this.root();\n            //console.log(`updated root ${root}`);\n        } finally {\n            if (!lock_already_acquired) {\n                this.lock.release();\n            }\n        }\n    }\n\n    async traverse(index, handler) {\n        let current_index = index;\n        for (let i = 0; i < this.n_levels; i++) {\n            let sibling_index = current_index;\n            if (current_index % 2 == 0) {\n                sibling_index += 1;\n            } else {\n                sibling_index -= 1;\n            }\n            await handler.handle_index(i, current_index, sibling_index);\n            current_index = Math.floor(current_index / 2);\n        }\n    }\n\n    async rollback(updates) {\n        await this.lock.acquireAsync();\n        try {\n            const update_log_key = MerkleTree.update_log_to_key(this.prefix);\n            const update_log_index = await this.storage.get(update_log_key);\n            for (let i = 0; i < updates; i++) {\n                const update_log_element_key = MerkleTree.update_log_element_to_key(this.prefix, update_log_index - i);\n                const update_element_log = JSON.parse(await this.storage.get(update_log_element_key));\n\n                await this.update(update_element_log.index, update_element_log.old_element, update_log_index - i - 1, true);\n            }\n        } finally {\n            this.lock.release();\n        }\n    }\n\n    async rollback_to_root(root) {\n        await this.lock.acquireAsync();\n        try {\n            const update_log_key = MerkleTree.update_log_to_key(this.prefix);\n            let update_log_index = await this.storage.get(update_log_key);\n            while (update_log_index >= 0) {\n                const update_log_element_key = MerkleTree.update_log_element_to_key(this.prefix, update_log_index);\n                const update_element_log = JSON.parse(await this.storage.get(update_log_element_key));\n\n                await this.update(update_element_log.index, update_element_log.old_element, update_log_index, true);\n                const current_root = await this.root();\n                if (current_root == root) {\n                    break;\n                }\n                update_log_index -= 1;\n            }\n            if (await this.root() != root) {\n                throw new Error(`could not rollback to root ${root}`);\n            }\n        } finally {\n            this.lock.release();\n        }\n    }\n}\n\n"]}},"error":null,"hash":"ec09050ebffe8bc70abdee47959b0a1a","cacheData":{"env":{}}}